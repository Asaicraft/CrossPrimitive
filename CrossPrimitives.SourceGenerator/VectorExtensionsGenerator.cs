using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Linq;
using System.Text;

namespace CrossPrimitives.SourceGenerator;

[Generator]
public class VectorExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var code = GenerateCode();

            ctx.AddSource(
                "VectorExtensions.generated.cs",
                SourceText.From(code, Encoding.UTF8)
            );
        });
    }

    private string GenerateCode()
    {
        // Описываем наши типы и их компоненты
        var floatTypes = new[]
        {
                new { TypeName = "Vector2", Components = new[] { "X", "Y" } },
                new { TypeName = "Vector3", Components = new[] { "X", "Y", "Z" } },
                new { TypeName = "Vector4", Components = new[] { "X", "Y", "Z", "W" } },
            };
        var intTypes = new[]
        {
                new { TypeName = "Vector2i", Components = new[] { "X", "Y" } },
                new { TypeName = "Vector3i", Components = new[] { "X", "Y", "Z" } },
                new { TypeName = "Vector4i", Components = new[] { "X", "Y", "Z", "W" } },
            };

        var allTypes = floatTypes.Concat(intTypes);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine();
        sb.AppendLine("namespace CrossPrimitives");  // подставьте ваш namespace
        sb.AppendLine("{");
        sb.AppendLine("    public static partial class VectorExtensions");
        sb.AppendLine("    {");

        // Для каждой пары типов, где исходный размер >= целевого
        foreach (var source in allTypes)
        {
            foreach (var target in allTypes)
            {
                var srcDim = source.Components.Length;
                var tgtDim = target.Components.Length;
                if (srcDim < tgtDim)
                {
                    continue;
                }

                foreach (var combo in GetPermutations(source.Components, tgtDim))
                {
                    var methodName = $"As{target.TypeName}{string.Join("", combo)}";
                    sb.AppendLine("        /// <summary>");
                    sb.AppendLine($"        /// Converts this {source.TypeName} to {target.TypeName} by taking components {string.Join(", ", combo)}.");
                    sb.AppendLine("        /// </summary>");
                    sb.Append("        public static ");
                    sb.Append(target.TypeName);
                    sb.Append(" ");
                    sb.Append(methodName);
                    sb.Append("(this ");
                    sb.Append(source.TypeName);
                    sb.Append(" v) => new(");

                    // Аргументы конструктора
                    var args = combo.Select(c =>
                        target.TypeName.EndsWith("i")
                            ? $"(int)v.{c}"
                            : $"v.{c}"
                    );
                    sb.Append(string.Join(", ", args));
                    sb.AppendLine(");");
                    sb.AppendLine();
                }
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static IEnumerable<string[]> GetPermutations(string[] items, int length)
    {
        if (length == 1)
        {
            return items.Select(x => new[] { x });
        }

        return items
            .SelectMany((item, idx) =>
                GetPermutations(items.Where((_, i) => i != idx).ToArray(), length - 1)
                    .Select(tail => (new[] { item }).Concat(tail).ToArray())
            );
    }
}